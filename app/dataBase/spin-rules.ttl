@prefix pdx: <http://poked-x.org/pokemon/> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

<http://poked-x.org/pokemon/rule/InferHasSameTypeAs> a spin:Rule ;
    spin:body pdx:construct3 .

<http://poked-x.org/pokemon/rule/InferLegendaryPokemon> a spin:Rule ;
    spin:body pdx:construct1 .

<http://poked-x.org/pokemon/rule/InferStrongAgainst> a spin:Rule ;
    spin:body pdx:construct2 .

<http://poked-x.org/pokemon/rule/InferStrongestMatchAgainst> a spin:Rule ;
    spin:body pdx:construct10 .

<http://poked-x.org/pokemon/rule/InferWeakestMatchAgainst> a spin:Rule ;
    spin:body pdx:construct11 .

pdx:construct1 a sp:Construct ;
    sp:text """
    CONSTRUCT {
        ?pokemon a pdx:LegendaryPokemon .
    }
    WHERE {
        ?pokemon pdx:isLegendary true .
    }
"""^^xsd:string .

pdx:construct2 a sp:Construct ;
    sp:text """
    CONSTRUCT {
        ?type1 pdx:strongAgainst ?type2 .
    }
    WHERE {
        ?type1 pdx:effectiveAgainst ?type2 ;
               pdx:effectiveness ?value .
        FILTER (?value > 1.5)
    }
"""^^xsd:string .

pdx:construct3 a sp:Construct ;
    sp:text """
    CONSTRUCT {
        ?p1 pdx:hasSameTypeAs ?p2 .
    }
    WHERE {
        ?p1 pdx:primaryType ?type .
        ?p2 pdx:primaryType ?type .
        FILTER (?p1 != ?p2)
    }
"""^^xsd:string .

<http://poked-x.org/pokemon/rule/InferStrongPokemon> a spin:Rule ;
    spin:body pdx:construct5 .

<http://poked-x.org/pokemon/rule/InferOldGeneration> a spin:Rule ;
    spin:body pdx:construct6 .

<http://poked-x.org/pokemon/rule/InferSharedPrimaryType> a spin:Rule ;
    spin:body pdx:construct7 .

<http://poked-x.org/pokemon/rule/InferFastPokemon> a spin:Rule ;
    spin:body pdx:construct8 .

<http://poked-x.org/pokemon/rule/InferMixedType> a spin:Rule ;
    spin:body pdx:construct9 .

pdx:construct5 a sp:Construct ;
    sp:text """
    CONSTRUCT {
        ?pokemon pdx:isStrong true .
    }
    WHERE {
        ?pokemon pdx:spAttack ?atk .
        FILTER (?atk > 120)
    }
"""^^xsd:string .

pdx:construct6 a sp:Construct ;
    sp:text """
    CONSTRUCT {
        ?pokemon pdx:isFromOldGen true .
    }
    WHERE {
        ?pokemon pdx:generation ?gen .
        FILTER (?gen <= 3)
    }
"""^^xsd:string .

pdx:construct7 a sp:Construct ;
    sp:text """
    CONSTRUCT {
        ?p1 pdx:sharesPrimaryTypeWith ?p2 .
    }
    WHERE {
        ?p1 pdx:primaryType ?type .
        ?p2 pdx:primaryType ?type .
        FILTER (?p1 != ?p2)
    }
"""^^xsd:string .

pdx:construct8 a sp:Construct ;
    sp:text """
    CONSTRUCT {
        ?pokemon pdx:isFast true .
    }
    WHERE {
        ?pokemon pdx:speed ?spd .
        FILTER (?spd >= 100)
    }
"""^^xsd:string .

pdx:construct9 a sp:Construct ;
    sp:text """
    CONSTRUCT {
        ?pokemon pdx:isMixedType true .
    }
    WHERE {
        ?pokemon pdx:primaryType ?t1 .
        ?pokemon pdx:secondaryType ?t2 .
        FILTER (?t1 != ?t2)
    }
"""^^xsd:string .

pdx:construct10 a sp:Construct ;
    sp:text """
    CONSTRUCT {
        ?attacker pdx:strongestMatchAgainst ?target .
        ?attacker pdx:matchStrength ?strength .
    }
    WHERE {
        # Get target Pokemon and its defensive stats and types
        ?target pdx:primaryType ?targetType1 ;
                pdx:defense ?targetDefense ;
                pdx:spDefense ?targetSpDefense ;
                pdx:hp ?targetHp .
        OPTIONAL { ?target pdx:secondaryType ?targetType2 . }
        
        # Get potential attacker Pokemon (different from target)
        ?attacker pdx:primaryType ?attackerType1 ;
                  pdx:attack ?attackerAttack ;
                  pdx:spAttack ?attackerSpAttack ;
                  pdx:speed ?attackerSpeed .
        OPTIONAL { ?attacker pdx:secondaryType ?attackerType2 . }
        FILTER (?attacker != ?target)
        
        # Calculate physical and special attack ratios
        BIND(?attackerAttack / ?targetDefense as ?physicalRatio)
        BIND(?attackerSpAttack / ?targetSpDefense as ?specialRatio)
        
        # Get the maximum attack ratio (attacker chooses best attack type)
        BIND(IF(?physicalRatio > ?specialRatio, ?physicalRatio, ?specialRatio) as ?attackRatio)
        
        # Calculate type effectiveness for primary attacker type
        OPTIONAL {
            ?eff1 pdx:attackingType ?attackerType1 ;
                   pdx:defendingType ?targetType1 ;
                   pdx:effectiveness ?eff1Value .
        }
        BIND(COALESCE(?eff1Value, 1.0) as ?modifier1)
        
        # Secondary type effectiveness (if target has secondary type)
        OPTIONAL {
            ?eff2 pdx:attackingType ?attackerType1 ;
                   pdx:defendingType ?targetType2 ;
                   pdx:effectiveness ?eff2Value .
        }
        BIND(IF(BOUND(?targetType2), COALESCE(?eff2Value, 1.0), 1.0) as ?modifier2)
        
        # Type effectiveness for secondary attacker type (if exists)
        OPTIONAL {
            ?eff3 pdx:attackingType ?attackerType2 ;
                   pdx:defendingType ?targetType1 ;
                   pdx:effectiveness ?eff3Value .
        }
        OPTIONAL {
            ?eff4 pdx:attackingType ?attackerType2 ;
                   pdx:defendingType ?targetType2 ;
                   pdx:effectiveness ?eff4Value .
        }
        
        # Calculate modifiers for secondary attacker type
        BIND(IF(BOUND(?attackerType2), COALESCE(?eff3Value, 1.0), 1.0) as ?modifier3)
        BIND(IF(BOUND(?attackerType2) && BOUND(?targetType2), COALESCE(?eff4Value, 1.0), 1.0) as ?modifier4)
        
        # Calculate best type effectiveness (choose best between primary and secondary types)
        BIND(?modifier1 * ?modifier2 as ?primaryTypeEff)
        BIND(IF(BOUND(?attackerType2), ?modifier3 * ?modifier4, 0.0) as ?secondaryTypeEff)
        BIND(IF(?secondaryTypeEff > ?primaryTypeEff, ?secondaryTypeEff, ?primaryTypeEff) as ?typeEffectiveness)
        
        # Speed factor (faster Pokemon have slight advantage)
        ?target pdx:speed ?targetSpeed .
        BIND(IF(?attackerSpeed > ?targetSpeed, 1.1, 1.0) as ?speedBonus)
        
        # HP factor (consider target's survivability)
        BIND(500.0 / (?targetHp + 100.0) as ?hpFactor)
        
        # Final strength calculation with multiple factors
        BIND(?attackRatio * ?typeEffectiveness * ?speedBonus * ?hpFactor as ?strength)
        
        # More inclusive filter - include various advantageous scenarios
        FILTER(
            ?typeEffectiveness >= 2.0 ||  # Super effective
            (?typeEffectiveness > 1.0 && ?attackRatio > 1.0) ||  # Type + stat advantage
            ?attackRatio > 1.5 ||  # Strong stat advantage
            (?attackRatio > 1.1 && ?speedBonus > 1.0)  # Moderate advantage with speed
        )
    }
"""^^xsd:string .

pdx:construct11 a sp:Construct ;
    sp:text """
    CONSTRUCT {
        ?attacker pdx:weakestMatchAgainst ?target .
        ?attacker pdx:matchWeakness ?weakness .
    }
    WHERE {
        # Get target Pokemon and its defensive stats and types
        ?target pdx:primaryType ?targetType1 ;
                pdx:defense ?targetDefense ;
                pdx:spDefense ?targetSpDefense ;
                pdx:attack ?targetAttack ;
                pdx:spAttack ?targetSpAttack .
        OPTIONAL { ?target pdx:secondaryType ?targetType2 . }
        
        # Get potential attacker Pokemon (different from target)
        ?attacker pdx:primaryType ?attackerType1 ;
                  pdx:attack ?attackerAttack ;
                  pdx:spAttack ?attackerSpAttack ;
                  pdx:defense ?attackerDefense ;
                  pdx:spDefense ?attackerSpDefense .
        OPTIONAL { ?attacker pdx:secondaryType ?attackerType2 . }
        FILTER (?attacker != ?target)
        
        # Calculate attack ratios (attacker vs target defense)
        BIND(?attackerAttack / ?targetDefense as ?physicalRatio)
        BIND(?attackerSpAttack / ?targetSpDefense as ?specialRatio)
        BIND(IF(?physicalRatio > ?specialRatio, ?physicalRatio, ?specialRatio) as ?attackRatio)
        
        # Calculate defensive ratios (target vs attacker defense)
        BIND(?targetAttack / ?attackerDefense as ?counterPhysicalRatio)
        BIND(?targetSpAttack / ?attackerSpDefense as ?counterSpecialRatio)
        BIND(IF(?counterPhysicalRatio > ?counterSpecialRatio, ?counterPhysicalRatio, ?counterSpecialRatio) as ?counterAttackRatio)
        
        # Calculate type effectiveness for attacker
        OPTIONAL {
            ?eff1 pdx:attackingType ?attackerType1 ;
                   pdx:defendingType ?targetType1 ;
                   pdx:effectiveness ?eff1Value .
        }
        BIND(COALESCE(?eff1Value, 1.0) as ?modifier1)
        
        OPTIONAL {
            ?eff2 pdx:attackingType ?attackerType1 ;
                   pdx:defendingType ?targetType2 ;
                   pdx:effectiveness ?eff2Value .
        }
        BIND(IF(BOUND(?targetType2), COALESCE(?eff2Value, 1.0), 1.0) as ?modifier2)
        
        # Secondary attacker type effectiveness
        OPTIONAL {
            ?eff3 pdx:attackingType ?attackerType2 ;
                   pdx:defendingType ?targetType1 ;
                   pdx:effectiveness ?eff3Value .
        }
        OPTIONAL {
            ?eff4 pdx:attackingType ?attackerType2 ;
                   pdx:defendingType ?targetType2 ;
                   pdx:effectiveness ?eff4Value .
        }
        
        BIND(IF(BOUND(?attackerType2), COALESCE(?eff3Value, 1.0), 1.0) as ?modifier3)
        BIND(IF(BOUND(?attackerType2) && BOUND(?targetType2), COALESCE(?eff4Value, 1.0), 1.0) as ?modifier4)
        
        # Best type effectiveness for attacker
        BIND(?modifier1 * ?modifier2 as ?primaryTypeEff)
        BIND(IF(BOUND(?attackerType2), ?modifier3 * ?modifier4, 0.0) as ?secondaryTypeEff)
        BIND(IF(?secondaryTypeEff > ?primaryTypeEff, ?secondaryTypeEff, ?primaryTypeEff) as ?typeEffectiveness)
        
        # Calculate reverse type effectiveness (target attacking attacker)
        OPTIONAL {
            ?reff1 pdx:attackingType ?targetType1 ;
                    pdx:defendingType ?attackerType1 ;
                    pdx:effectiveness ?reff1Value .
        }
        BIND(COALESCE(?reff1Value, 1.0) as ?rmodifier1)
        
        OPTIONAL {
            ?reff2 pdx:attackingType ?targetType1 ;
                    pdx:defendingType ?attackerType2 ;
                    pdx:effectiveness ?reff2Value .
        }
        BIND(IF(BOUND(?attackerType2), COALESCE(?reff2Value, 1.0), 1.0) as ?rmodifier2)
        
        BIND(?rmodifier1 * ?rmodifier2 as ?reverseTypeEff)
        
        # Weakness calculation considers multiple disadvantage factors
        BIND((?counterAttackRatio * ?reverseTypeEff) / (?attackRatio * ?typeEffectiveness) as ?weakness)
        
        # More inclusive filter for weak matchups
        FILTER(
            ?typeEffectiveness <= 0.5 ||  # Not very effective or immune
            (?typeEffectiveness < 1.0 && ?attackRatio < 1.0) ||  # Type + stat disadvantage
            ?attackRatio < 0.7 ||  # Poor stat matchup
            (?weakness > 1.5) ||  # Overall disadvantage ratio
            (?reverseTypeEff >= 2.0 && ?counterAttackRatio > 1.0)  # Target has super effective counter
        )
    }
"""^^xsd:string .